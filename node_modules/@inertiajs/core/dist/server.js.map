{
  "version": 3,
  "sources": ["../src/server.ts"],
  "sourcesContent": ["import { createServer, IncomingMessage } from 'http'\nimport cluster from 'node:cluster'\nimport { availableParallelism } from 'node:os'\nimport * as process from 'process'\nimport { InertiaAppResponse, Page } from './types'\n\ntype AppCallback = (page: Page) => InertiaAppResponse\ntype RouteHandler = (request: IncomingMessage) => Promise<unknown>\ntype ServerOptions = {\n  port?: number\n  cluster?: boolean\n}\ntype Port = number\n\nconst readableToString: (readable: IncomingMessage) => Promise<string> = (readable) =>\n  new Promise((resolve, reject) => {\n    let data = ''\n    readable.on('data', (chunk) => (data += chunk))\n    readable.on('end', () => resolve(data))\n    readable.on('error', (err) => reject(err))\n  })\n\nexport default (render: AppCallback, options?: Port | ServerOptions): void => {\n  const _port = typeof options === 'number' ? options : (options?.port ?? 13714)\n  const _useCluster = typeof options === 'object' && options?.cluster !== undefined ? options.cluster : false\n\n  const log = (message: string) => {\n    console.log(\n      _useCluster && !cluster.isPrimary\n        ? `[${cluster.worker?.id ?? 'N/A'} / ${cluster.worker?.process?.pid ?? 'N/A'}] ${message}`\n        : message,\n    )\n  }\n\n  if (_useCluster && cluster.isPrimary) {\n    log('Primary Inertia SSR server process started...')\n\n    for (let i = 0; i < availableParallelism(); i++) {\n      cluster.fork()\n    }\n\n    return\n  }\n\n  const routes: Record<string, RouteHandler> = {\n    '/health': async () => ({ status: 'OK', timestamp: Date.now() }),\n    '/shutdown': () => process.exit(),\n    '/render': async (request) => render(JSON.parse(await readableToString(request))),\n    '/404': async () => ({ status: 'NOT_FOUND', timestamp: Date.now() }),\n  }\n\n  createServer(async (request, response) => {\n    const dispatchRoute = routes[<string>request.url] || routes['/404']\n\n    try {\n      response.writeHead(200, { 'Content-Type': 'application/json', Server: 'Inertia.js SSR' })\n      response.write(JSON.stringify(await dispatchRoute(request)))\n    } catch (e) {\n      console.error(e)\n    }\n\n    response.end()\n  }).listen(_port, () => log('Inertia SSR server started.'))\n\n  log(`Starting SSR server on port ${_port}...`)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA8C;AAC9C,0BAAoB;AACpB,qBAAqC;AACrC,cAAyB;AAWzB,IAAM,mBAAmE,CAAC,aACxE,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC/B,MAAI,OAAO;AACX,WAAS,GAAG,QAAQ,CAAC,UAAW,QAAQ,KAAM;AAC9C,WAAS,GAAG,OAAO,MAAM,QAAQ,IAAI,CAAC;AACtC,WAAS,GAAG,SAAS,CAAC,QAAQ,OAAO,GAAG,CAAC;AAC3C,CAAC;AAEH,IAAO,iBAAQ,CAAC,QAAqB,YAAyC;AAC5E,QAAM,QAAQ,OAAO,YAAY,WAAW,UAAW,SAAS,QAAQ;AACxE,QAAM,cAAc,OAAO,YAAY,YAAY,SAAS,YAAY,SAAY,QAAQ,UAAU;AAEtG,QAAM,MAAM,CAAC,YAAoB;AAC/B,YAAQ;AAAA,MACN,eAAe,CAAC,oBAAAA,QAAQ,YACpB,IAAI,oBAAAA,QAAQ,QAAQ,MAAM,KAAK,MAAM,oBAAAA,QAAQ,QAAQ,SAAS,OAAO,KAAK,KAAK,OAAO,KACtF;AAAA,IACN;AAAA,EACF;AAEA,MAAI,eAAe,oBAAAA,QAAQ,WAAW;AACpC,QAAI,+CAA+C;AAEnD,aAAS,IAAI,GAAG,QAAI,qCAAqB,GAAG,KAAK;AAC/C,0BAAAA,QAAQ,KAAK;AAAA,IACf;AAEA;AAAA,EACF;AAEA,QAAM,SAAuC;AAAA,IAC3C,WAAW,aAAa,EAAE,QAAQ,MAAM,WAAW,KAAK,IAAI,EAAE;AAAA,IAC9D,aAAa,MAAc,aAAK;AAAA,IAChC,WAAW,OAAO,YAAY,OAAO,KAAK,MAAM,MAAM,iBAAiB,OAAO,CAAC,CAAC;AAAA,IAChF,QAAQ,aAAa,EAAE,QAAQ,aAAa,WAAW,KAAK,IAAI,EAAE;AAAA,EACpE;AAEA,gCAAa,OAAO,SAAS,aAAa;AACxC,UAAM,gBAAgB,OAAe,QAAQ,GAAG,KAAK,OAAO,MAAM;AAElE,QAAI;AACF,eAAS,UAAU,KAAK,EAAE,gBAAgB,oBAAoB,QAAQ,iBAAiB,CAAC;AACxF,eAAS,MAAM,KAAK,UAAU,MAAM,cAAc,OAAO,CAAC,CAAC;AAAA,IAC7D,SAAS,GAAG;AACV,cAAQ,MAAM,CAAC;AAAA,IACjB;AAEA,aAAS,IAAI;AAAA,EACf,CAAC,EAAE,OAAO,OAAO,MAAM,IAAI,6BAA6B,CAAC;AAEzD,MAAI,+BAA+B,KAAK,KAAK;AAC/C;",
  "names": ["cluster"]
}
